 **RAII (Resource Acquisition Is Initialization) в C++** — это **принцип управления ресурсами**, который предполагает, что **получение ресурса производится при инициализации объекта, а освобождение — в деструкторе объекта**.
 Проблемы, которые RAII решает:

1. **Утечки памяти**: Без RAII разработчику приходится вручную отслеживать и освобождать выделенную память. Забытая операция освобождения памяти может привести к утечкам. RAII гарантирует, что память будет автоматически освобождена при уничтожении объекта.
    
2. **Неопределенное поведение**: Если ресурсы не управляются должным образом, это может привести к неопределенному поведению программы. RAII гарантирует, что ресурсы всегда находятся в определенном состоянии.
    
3. **Исключения и безопасность**: RAII позволяет обрабатывать исключения более элегантно и безопасно. Ресурсы будут автоматически освобождены даже в случае возникновения исключительных ситуаций.
## RAII - это про unique_ptr и shared_ptr

#### std::unique_ptr
==Если хочу разместить что-то в динамической памяти - это первый указатель, о котором стоит подумать==
`std::unique_ptr` владеет объектом, на который он указывает, и никакие другие умные указатели не могут на него указывать. Когда std::unique_ptr выходит из области видимости, объект удаляется. Это полезно, когда вы работаете с временным, динамически выделенным ресурсом, который может быть уничтожен после выхода из области действия.
#### std::shared_ptr
`std::shared_ptr` представляет собой умный указатель, который может быть разделяем между несколькими `std::shared_ptr`. Это означает, что несколько указателей могут владеть одним и тем же ресурсом, и память будет освобождена только после того, как последний `std::shared_ptr` перестанет ссылаться на ресурс.

#### std::weak_ptr*(указатель со звёздочкой)
Чтобы разорвать цикличность, необходимо использовать [std::weak_ptr](https://en.cppreference.com/w/cpp/memory/weak_ptr). Это фактически умный указатель non owning, предназначенный для использования именно с `std::shared_ptr`. Копирование `std::weak_ptr` не увеличивает счётчик в `std::shared_ptr`, а значит и не защищает объект от уничтожения. При этом всегда имеется возможность проверить, существует ли ещё объект, на который ссылается `std::weak_ptr`. 
Т.е. это указатель для решения конфликтов 
#### std::move
Move семантика позволяет переместить объект вместо его копирования для увеличения производительности. Другими словами, перемещение – это считывание со стиранием (destructive read). Буквально мы отдаём ссылку на объект, другому объекту для использования
```cpp
void func(std::unique_ptr<X> a) {}
int main() {
	auto a = std::make_unique<X>();
	func(a); //Не скомпилируется, std::unique_ptr нельзя копировать, потому что иначе у объекта было бы несколько владельцев 
	func(std::move(a)); //Владение объектом передано в func, main больше не владеет объектом, на выходе из func объект будет уничтожен 
}
```

## Boost
#### boost::intrusive_ptr
intrusive_ptr представляет собой облегчённую версию shared_ptr, специально предназначенную для классов, имеющих встроенные механизмы подсчёта ссылок. Для таких классов intrusive_ptr позволяет реализовать эффективный механизм совместного владения с подсчётом ссылок, но без дополнительных затрат. Соответственно, отсутствует и аналог weak_ptr. Во всём остальном семантика intrusive_ptr повторяет семантику shared_ptr.


