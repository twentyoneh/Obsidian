## Имена должны передавать намерения программиста
Избегать дезинформации - 
Сколько времени понадобится, чтобы заметить незначительное различие в XYZControllerForEfficientHandlingOfStrings в одном модуле и XYZControllerForEfficientStorageOfStrings где-то в другом месте?
Сходное представление сходных концепций — **информация.** Непоследовательное представление — **дезинформация**.
При отсутствии жестких именных схем имя moneyAmount не отличается от money, customerInfo не отличается от customer, accountData не отличается от account, а theMessage — от message. Записывайте различающиеся имена так, чтобы читатель кода понимал, какой смысл заложен в этих различиях.
Самая распространенная буква английского алфавита с большой вероятностью встречается в любом текстовом фрагменте каждой программы. В этом отношении длинные имена лучше коротких, а имена, удобные для поиска, лучше констант в коде
Не добавляйте избыточный контекст
Если вы работаете над вымышленным приложением «Gas Station Deluxe», не стоит снабжать имя каждого класса префиксом GSD.

## Функции
Первое правило: функции должны быть компактными. Второе правило: функции должны быть еще компактнее. 
Максимальный уровень отступов в функции не должен превышать одного-двух.
Код должен читаться как рассказ — сверху вниз
Оператор swich - стр 56
В идеальном случае количество аргументов функции равно нулю (нуль-арная функция). Далее следуют функции с одним аргументом (унарные) и с двумя аргументами (бинарные). Функций с тремя аргументами (тернарных) следует по возможности избегать. Необходимость функций с большим количеством аргументов (полиарных) должна быть подкреплена очень вескими доводами — и все равно такие функции лучше не использовать.
Если функция должна получать более двух или трех аргументов, весьма вероятно, что некоторые из этих аргументов стоит упаковать в отдельном классе. Рассмотрим следующие два объявления:
```
Circle makeCircle(double x, double y, double radius);
Circle makeCircle(Point center, double radius);
```
Выбор хорошего имени для функции способен в значительной мере объяснить смысл функции, а также порядок и смысл ее аргументов.
Например, assertEquals можно записать в виде assertExpectedEqualsActual(expected,actual). Это в значительной мере решает проблему запоминания порядка аргументов.
Возвращение кодов ошибок функциями-командами является неочевидным нарушением принципа разделения команд и запросов. Оно поощряет использование команд в предикатных выражениях if:
if (deletePage(page) == E_OK)
Такие конструкции не страдают от смешения глаголов с прилагательными, но они приводят к созданию структур слишком глубокой вложенности. При возвращении кода ошибки возникает проблема: вызывающая сторона должна немедленно отреагировать на ошибку.
```
if (deletePage(page) == E_OK) {
 if (registry.deleteReference(page.name) == E_OK) {
 if (configKeys.deleteKey(page.name.makeKey()) == E_OK){
 logger.log("page deleted");
 } else {
 logger.log("configKey not deleted");
 }
 } else
{
 logger.log("deleteReference from registry failed");
 }
} else {
 logger.log("delete failed");
 return E_ERROR;
}
```
С другой стороны, если вместо возвращения кодов ошибок используются исключения, то код обработки ошибок изолируется от ветви нормального выполнения и упрощается:
```
try {
 deletePage(page);
 registry.deleteReference(page.name);
 configKeys.deleteKey(page.name.makeKey());
}
catch (Exception e) {
 logger.log(e.getMessage());
}
```
Блоки try/catch выглядят весьма уродливо. Они запутывают структуру кода и смешивают обработку ошибок с нормальной обработкой. По этой причине тела блоков try и catch рекомендуется выделять в отдельные функции.
```
public void delete(Page page) {
 try {
 deletePageAndAllReferences(page);
 }
 catch (Exception e) {
 logError(e);
 }
}
```




