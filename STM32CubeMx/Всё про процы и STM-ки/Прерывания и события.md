**Interrupt** — это прерывание. При прерывании обычно программа пакует регистры в стек и бросается по вектору, а оттуда через JMP сигает уже в обработчик прерывания. В кортексах все немного не так. Тут вектора прерывания это просто вектор-адреса лежащие в нужном месте. В виде констант. А при прерывании прога не прыгает на вектор, а берет этот вектор-адрес и сразу же пихает его в програмный счетчик, тем самым переходит сразу на обработчик. Так быстрей, исчезает лишняя операция по переходу на вектор.  

**Event** — это аппаратное событие. Опустел буфер UART — держи event, натикал таймер — еще один event. Событие может вызвать прерывание, может запустить какую-либо периферию, например пнуть DMA, чтобы оно выгрузило данные. Но событие далеко не всегда может вызвать прерывание. **Каждое прерывание вызывается событием, но не каждое событие вызывает прерывание.** Вот. Так что надо отличать.
Теперь, если нам потребуется создать обработчик прерывания. Допустим для внешнего прерывания по изменению состояния вывода EXTI1 мы должны будем нарисовать в коде вот такую конструкцию:

| 1<br>2<br>3<br>4<br>5 | // Int Vectors<br>void EXTI1_IRQHandler(void)<br>{<br> <br>} |
| --------------------- | ------------------------------------------------------------ |

------------------------------------------------------
Все #вектора_прерываний и #номера_обработчиков_прерываний можно посмотреть в файле startup_stm32f767xx.s

***Векторы прерываний нужны для того чтобы быстро найти нужную функцию обработчик***

**Разрешение прерываний**  
Для разрешения прерываний надо сделать три вещи:  
 
- Разрешить глобальные прерывания
- Разрешить нужное прерывание в NVIC
- Настроить и разрешить конкретные прерывания непосредственно в периферии. Т.е. настроить нужные events на прерывания.
**Разрешение глобальных прерываний**  
Это просто, достаточно всего лишь поставить флажок состояния процессора. В CMSIS за это отвечает крошечная функция`
`__enable_irq ();`
**Разрешить прерывания в #NVIC**  
Настройка прерываний в NVIC чуть более сложное дело, но не намного. Описание на NVIC можно найти в файле PM0056 STM32F10xxx Cortex-M3 programming manual. Там описывается только то, что есть в ядре Cortex M3. Можно конечно открыть более общее описание, взятое с сайта ARM. Но там будут небольшие отличия. Например, у STM32 урезана система группировки приоритетов. И другие мелочи. Но в целом все похоже.
За работу с прерываниями в NVIC отвечают несколько регистров
![[Pasted image 20240710120213.png]]
- **ISER** — Interrupt Set Enable Register. Запись бита в нужную позицию включает прерывание.
- **ICER** — Interrupt Clr Enable Register. Запись сюда наоборот выключает прерывание.

Запись 1 в биты этих регистров запрещает/разрешает прерывания. Запись 0 не делает ничего, а чтение возвращает текущее состояние разрешено/запрещено  
 

- **ISPR** — Interrupt Set Pending Register. Поставить прерывание в ожидание.
- **IСPR** — Interrupt Clr Pending Register. Сбросить прерывание с ожидания.

Запись 1 в биты этих регистров ставит/снимает прерывания в очередь на исполнение. Запись 0 не делает ничего, а чтение возвращает текущее состояние прерывания. Ждет он обработки или уже нет. Т.е. если в этом регистре где то стоит бит 1, значит это прерывание еще не вызывалось.

- **IABR** — Interrupt active bit registers. Регистр показывающий активно ли в данный момент прерывание. Автоматически ставится когда мы попадаем в обработчик и автоматом же снимается когда мы уходим из него. Этот регистр можно только читать.

Аппаратное прерывание это сигнал, сообщающий о каком-то событии. По его приходу выполнение программы приостанавливается, и управление переходит на функцию обработки прерывания (обработчик прерывания). После отработки функции управление возвращается в прерванный код программы.
Событие – это нечто происшедшее с аппаратным узлом микроконтроллера. Например, переполнился таймер, в порт UART пришло данное, на внешнем входе изменился уровень сигнала и т.п.